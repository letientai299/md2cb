//! Embedded JavaScript runtime for running MathJax.
//!
//! Uses QuickJS via rquickjs to execute the bundled MathJax library
//! and convert LaTeX math expressions to SVG.

use rquickjs::{Context, Runtime};
use std::cell::RefCell;

/// Embedded MathJax bundle (generated by scripts/build-mathjax.js)
const MATHJAX_BUNDLE: &str = include_str!("../assets/mathjax-bundle.js");

// Thread-local JS runtime (QuickJS is not thread-safe, uses Rc internally)
thread_local! {
    static JS_RUNTIME: RefCell<Option<JsRuntimeInner>> = const { RefCell::new(None) };
}

/// Inner runtime state
struct JsRuntimeInner {
    context: Context,
    // Keep runtime alive - Context borrows from it
    _runtime: Runtime,
}

impl JsRuntimeInner {
    /// Create a new JS runtime and initialize MathJax
    fn new() -> Result<Self, String> {
        let runtime = Runtime::new().map_err(|e| format!("Failed to create JS runtime: {e}"))?;

        // Increase limits for complex math expressions
        // MathJax can be deeply recursive and memory-intensive for complex LaTeX
        runtime.set_max_stack_size(8 * 1024 * 1024); // 8MB stack
        runtime.set_memory_limit(128 * 1024 * 1024); // 128MB memory

        let context =
            Context::full(&runtime).map_err(|e| format!("Failed to create JS context: {e}"))?;

        // Initialize MathJax bundle
        context.with(|ctx| {
            ctx.eval::<(), _>(MATHJAX_BUNDLE.as_bytes().to_vec())
                .map_err(|e| format!("Failed to initialize MathJax: {e}"))
        })?;

        Ok(Self {
            context,
            _runtime: runtime,
        })
    }

    /// Convert LaTeX to SVG using MathJax
    fn latex_to_svg(&self, latex: &str, display: bool) -> Result<String, String> {
        self.context.with(|ctx| {
            // Escape the latex string for JavaScript
            let escaped_latex = escape_js_string(latex);

            let js_code = format!("convertLatexToSvg('{escaped_latex}', {display})");

            let result: String = ctx
                .eval(js_code.into_bytes())
                .map_err(|e| format!("JS execution error: {e}"))?;

            // Parse JSON result from MathJax
            let parsed: serde_json::Value =
                serde_json::from_str(&result).map_err(|e| format!("JSON parse error: {e}"))?;

            if parsed["success"].as_bool() == Some(true) {
                parsed["svg"]
                    .as_str()
                    .map(|s| s.to_string())
                    .ok_or_else(|| "Missing SVG in result".to_string())
            } else {
                Err(parsed["error"]
                    .as_str()
                    .unwrap_or("Unknown MathJax error")
                    .to_string())
            }
        })
    }
}

/// Escape a string for safe inclusion in JavaScript code
fn escape_js_string(s: &str) -> String {
    let mut result = String::with_capacity(s.len() * 2);
    for c in s.chars() {
        match c {
            '\\' => result.push_str("\\\\"),
            '\'' => result.push_str("\\'"),
            '"' => result.push_str("\\\""),
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            '\u{2028}' => result.push_str("\\u2028"),
            '\u{2029}' => result.push_str("\\u2029"),
            _ => result.push(c),
        }
    }
    result
}

/// Convert LaTeX to SVG (public API)
pub fn convert_latex_to_svg(latex: &str, display: bool) -> Result<String, String> {
    JS_RUNTIME.with(|cell| {
        let mut runtime_ref = cell.borrow_mut();

        // Initialize runtime if needed
        if runtime_ref.is_none() {
            *runtime_ref = Some(JsRuntimeInner::new()?);
        }

        // Use the runtime
        runtime_ref
            .as_ref()
            .ok_or_else(|| "Runtime not initialized".to_string())?
            .latex_to_svg(latex, display)
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_latex() {
        let svg = convert_latex_to_svg("x^2", false).unwrap();
        assert!(svg.contains("<svg"));
        assert!(svg.contains("xmlns="));
    }

    #[test]
    fn test_display_mode() {
        let svg = convert_latex_to_svg("\\int_0^1 x dx", true).unwrap();
        assert!(svg.contains("<svg"));
    }

    #[test]
    fn test_complex_latex() {
        let svg =
            convert_latex_to_svg(r"\begin{split} a &= b \\ c &= d \end{split}", true).unwrap();
        assert!(svg.contains("<svg"));
    }

    #[test]
    fn test_escape_js_string() {
        assert_eq!(escape_js_string("a\\b"), "a\\\\b");
        assert_eq!(escape_js_string("a'b"), "a\\'b");
        assert_eq!(escape_js_string("a\nb"), "a\\nb");
    }
}
